/*
	Copyright 2020-2021 David "Alemarius Nexus" Lerch

	This file is part of RemoteMono.

	RemoteMono is free software: you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published
	by the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	RemoteMono is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with RemoteMono.  If not, see <https://www.gnu.org/licenses/>.
 */

#pragma once

#include "../config.h"

#include <type_traits>
#include <tuple>
#include "RMonoAPIBase_Def.h"
#include "RMonoAPIFunctionTypeAdapters.h"
#include "RMonoAPIFunctionSimple_Def.h"
#include "RMonoAPIFunctionCommon_Def.h"
#include "abi/RMonoABITypeTraits.h"
#include "../util.h"




namespace remotemono
{



// **************************************************************
// *															*
// *						BASE CLASS							*
// *															*
// **************************************************************

/**
 * A component of RMonoAPIFunction, this class provides the high-level logic for invoking the wrapper method
 * around a Mono API function. On the frontend, it provides the invoke() method, which is the one that is
 * directly called by RMonoAPI. On the backend, it interfaces the wrapper function generated by
 * RMonoAPIFunctionWrap, where it eventually calls invokeWrap() (or RMonoAPIFunctionRaw::invokeRaw() if no
 * wrapper function is required).
 *
 * It is responsible for converting parameter and return types from between APIType and WrapType, and it
 * generated the remote data block that is used by the wrapper function.
 *
 * The remote data block is a single block of memory that is allocated whenever a remote wrapper function
 * is called. It contains additional data that does not directly fit into the parameters, as well as the
 * data that many of the pointer parameters actually point to. For output parameters or certain return
 * values, data is also written into this data block by the wrapper function, and read back into the local
 * process by this class. The format of the data block is an implementation detail shared by this class and
 * RMonoAPIFunctionWrap, and both classes usually need to be updated when it is changed.
 * For many parameters, the value passed to the wrapper function is a pointer into the data block, and the
 * actual data intended for the raw Mono API function is instead written into the data block along with
 * additional metadata.
 *
 * This class uses template metaprogramming on the parameter and return types of the Mono API function signature
 * defined in RMonoAPIBackend in order to automate generation of the correct parameters and data block. In
 * essence, it iterates (using recursion) over all parameters and the return type and handles each parameter
 * separately.
 */
template <class CommonT, typename ABI, typename RetT, typename... ArgsT>
class RMonoAPIFunctionAPIBase : public RMonoAPIFunctionCommon<ABI>
{
public:
	typedef RetT APIRetType;
	typedef std::tuple<ArgsT...> APIArgsTuple;

public:
	RMonoAPIFunctionAPIBase() {}
	~RMonoAPIFunctionAPIBase() {}

	/**
	 * Calls the wrapper function (or the raw function if no wrapper is needed), converting arguments from their high-level
	 * representation (the APITypes) to the wrapper representation (the WrapTypes) and generating the remote data block.
	 */
	RetT invoke(ArgsT... args)
	{
		if constexpr(!std::is_same_v<RetT, void>) {
			return static_cast<typename RMonoAPIFunctionAPITraits<CommonT>::APIComponent*>(this)
					->invokeAPIInternal(std::tuple<ArgsT...>(args...));
		} else {
			static_cast<typename RMonoAPIFunctionAPITraits<CommonT>::APIComponent*>(this)
					->invokeAPIInternal(std::tuple<ArgsT...>(args...));
		}
	}

	/**
	 * An alias for invoke().
	 */
	RetT operator()(ArgsT... args) { return invoke(args...); }
};






// **************************************************************
// *															*
// *						ADAPTER CHAIN						*
// *															*
// **************************************************************

// Can be used to adapt the definition types into the API types, e.g. by adding, changing or removing arguments.

template <typename CommonT, typename ABI, typename RetT, typename... ArgsT>
class RMonoAPIFunctionAPIAdapterFinal : public RMonoAPIFunctionAPIBase <
		CommonT,
		ABI,
		typename RMonoAPIReturnTypeAdapter<ABI, RetT>::APIType,
		typename RMonoAPIParamTypeAdapter<ABI, ArgsT>::APIType...
		> {};



template <typename Enable, typename CommonT, typename ABI, typename RetT, typename... ArgsT>
class RMonoAPIFunctionAPIAdapterRetToOutParam;

// Transform Variant return type to output parameter
template <typename CommonT, typename ABI, typename RetT, typename... ArgsT>
class RMonoAPIFunctionAPIAdapterRetToOutParam <
		std::enable_if_t<std::is_base_of_v<RMonoVariant, typename RetT::Type>>,
		CommonT, ABI, RetT, ArgsT...
	> : public RMonoAPIFunctionAPIAdapterFinal<CommonT, ABI, void, tags::ParamOut<RMonoVariant>, ArgsT...> {};

template <typename CommonT, typename ABI, typename RetT, typename... ArgsT>
class RMonoAPIFunctionAPIAdapterRetToOutParam <
		std::enable_if_t<!std::is_base_of_v<RMonoVariant, typename RetT::Type>>,
		CommonT, ABI, RetT, ArgsT...
	> : public RMonoAPIFunctionAPIAdapterFinal<CommonT, ABI, RetT, ArgsT...> {};



template <typename Enable, typename CommonT, typename ABI, typename RetT, typename... ArgsT>
class RMonoAPIFunctionAPIAdapter : public RMonoAPIFunctionAPIAdapterRetToOutParam<void, CommonT, ABI, RetT, ArgsT...> {};






// **************************************************************
// *															*
// *						FRONT CLASS							*
// *															*
// **************************************************************


/**
 * Documentation for this class is at RMonoAPIFunctionAPIBase.
 *
 * @see RMonoAPIFunctionAPIBase
 */
template <typename CommonT, typename ABI, typename RetT, typename... ArgsT>
class RMonoAPIFunctionAPI : public RMonoAPIFunctionAPIAdapter<void, CommonT, ABI, RetT, ArgsT...>
{
private:
	typedef RMonoABITypeTraits<ABI> ABITypeTraits;

	REMOTEMONO_ABI_TYPETRAITS_TYPEDEFS(ABITypeTraits)

	typedef typename RMonoAPIFunctionAPITraits<CommonT>::APIRetType CommonAPIRetType;
	typedef typename RMonoAPIFunctionAPITraits<CommonT>::APIArgsTuple CommonAPIArgsTuple;

	typedef typename RMonoAPIFunctionWrapTraits<CommonT>::WrapRetType CommonWrapRetType;
	typedef typename RMonoAPIFunctionWrapTraits<CommonT>::WrapArgsTuple CommonWrapArgsTuple;

	typedef typename RMonoAPIFunctionRawTraits<CommonT>::RawRetType CommonRawRetType;
	typedef typename RMonoAPIFunctionRawTraits<CommonT>::RawArgsTuple CommonRawArgsTuple;

	typedef std::conditional_t<std::is_same_v<CommonWrapRetType, void>, int, CommonRawRetType> RawRetTypeOptional;
	typedef std::conditional_t<std::is_same_v<CommonWrapRetType, void>, int, CommonWrapRetType> WrapRetTypeOptional;
	typedef std::conditional_t<std::is_same_v<CommonAPIRetType, void>, int, CommonAPIRetType> APIRetTypeOptional;

public:
	typedef RMonoAPIFunctionAPI<CommonT, ABI, RetT, ArgsT...> Self;

private:
	typedef RMonoVariant Variant;
	typedef RMonoVariantArray VariantArray;

	typedef typename RMonoAPIFunctionCommon<ABI>::variantflags_t variantflags_t;

	struct InvokeContext
	{
		InvokeContext(CommonAPIArgsTuple& apiArgs) : apiArgs(apiArgs) {}

		CommonAPIArgsTuple& apiArgs;
		CommonWrapArgsTuple wrapArgs;
	};

	enum InvokeStep
	{
		StepDataBlockGetSize,
		StepDataBlockFill,
		StepDataBlockRead
	};

public:
	CommonAPIRetType invokeAPIInternal(CommonAPIArgsTuple&& args);

protected:
	void resetAPI()
	{
	}

private:
	ABI* getABI() { return static_cast<CommonT*>(this)->getABI(); }
	RMonoAPIBase* getRemoteMonoAPI() { return static_cast<CommonT*>(this)->getRemoteMonoAPI(); }

	void alignBuf(char** buf, irmono_voidp* rBufAddr, size_t alignment)
	{
		size_t misalignment = size_t(align(*rBufAddr, alignment) - *rBufAddr);
		*buf += misalignment;
		*rBufAddr += (irmono_voidp) misalignment;
	}
	void shiftBuf(char** buf, irmono_voidp* rBufAddr, size_t shift)
	{
		*buf += shift;
		*rBufAddr += (irmono_voidp) shift;
	}


	CommonAPIRetType convertRawCallRet(RawRetTypeOptional x)
	{
		if constexpr(!std::is_same_v<CommonAPIRetType, void>) {
			if constexpr(std::is_base_of_v<RMonoHandleTag, typename RetT::Type>) {
				if constexpr(tags::has_return_tag_v<RetT, tags::ReturnOwnTag>) {
					return CommonAPIRetType(x, getRemoteMonoAPI(), true);
				} else {
					return CommonAPIRetType(x, getRemoteMonoAPI(), false);
				}
			} else {
				return x;
			}
		}
	}

	template <typename DefArgT>
	typename RMonoAPIParamTypeAdapter<ABI, DefArgT>::RawType convertRawCallArg(typename RMonoAPIParamTypeAdapter<ABI, DefArgT>::APIType x)
	{
		if constexpr(std::is_base_of_v<RMonoHandleTag, typename DefArgT::Type>) {
			return getABI()->p2i_rmono_voidp(*x);
		} else {
			return x;
		}
	}

	variantflags_t buildVariantFlags(const RMonoVariant& v, bool out)
	{
		variantflags_t flags = 0;

		if (v.getType() == Variant::TypeMonoObjectPtr) {
			flags |= Self::ParamFlagMonoObjectPtr;
		} else if (v.getType() == Variant::TypeRawPtr) {
			flags |= Self::ParamFlagDirectPtr;
		}

		if (out) {
			flags |= Self::ParamFlagOut;
		}
		if (!v.isAutoUnboxEnabled()) {
			flags |= Self::ParamFlagDisableAutoUnbox;
		}

		return flags;
	}

	template <typename ArgT>
	RMonoVariant::Direction getVariantDirectionForArg(const RMonoVariant& v)
	{
		RMonoVariant::Direction dir;

		if constexpr (tags::has_param_tag_v<ArgT, tags::ParamInOutTag>) {
			dir = RMonoVariant::DirectionInOut;
		} else if constexpr (tags::has_param_tag_v<ArgT, tags::ParamOutTag>) {
			dir = RMonoVariant::DirectionOut;
		} else {
			dir = RMonoVariant::DirectionIn;
		}

		if constexpr (tags::has_param_tag_v<ArgT, tags::ParamOvwrInOutTag>) {
			RMonoVariant::Direction ovwrDir = v.getDirection();

			if (ovwrDir != RMonoVariant::DirectionDefault) {
				dir = ovwrDir;
			}
		}

		return dir;
	}




	void handleInvokeStep (
			InvokeContext& ctx,
			InvokeStep step,
			char** buf,
			irmono_voidp* rBufAddr,
			WrapRetTypeOptional* wrapRetval,
			APIRetTypeOptional* apiRetval
			);


	template <size_t apiArgIdx, size_t wrapArgIdx, typename ArgT, typename... RestT>
	void handleInvokeStepArg (
			InvokeContext& ctx,
			InvokeStep step,
			char** buf,
			irmono_voidp* rBufAddr,
			PackHelper<ArgT>,
			PackHelper<RestT>... rest
			);
	template <size_t apiArgIdx, size_t wrapArgIdx>
	void handleInvokeStepArg (
			InvokeContext& ctx,
			InvokeStep step,
			char** buf,
			irmono_voidp* rBufAddr
			) {}
};


}

